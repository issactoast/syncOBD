---
title: Data analysis report - Root Insurance

# Use letters for affiliations
author:
  - name: Issac Lee
    affiliation: a
address:
  - code: a
    address: Department of Statistics & Actuarial Science, 241 Schaeffer Hall, Iowa City, Iowa 52242-1409

# Optional: line of arbitrary text with additional information.
# Could be used, for example, to mention the bibliographic info in a post-print.
# If not specified, defaults to "This version was compiled on \today"
#date_subtitle: Published in *Journal of Statistical Software*, 2018

# For footer text  TODO(fold into template, allow free form two-authors)
lead_author_surname: Author and Author

# Place eg a DOI URL or CRAN Package URL here
doi_footer: "https://cran.r-project.org/package=YourPackage"

# Abstract
abstract: |
  This report illustrates how I approach the project and the decision making the process for Root insurance's data analysis project. The goal of this project is to find the best-matched OBDII trip data, which corresponds to a trip data from a user's smartphone. The data analysis process appears in the first chapter, and the instructional manual follows in the later chapter. The `R` code implementations follow Google's `R` code style guide.

# Optional: Acknowledgements
acknowledgements: |

# Optional: One or more keywords
keywords:

# Paper size for the document, values of letter and a4
papersize: letter

# Font size of the document, values of 9pt (default), 10pt, 11pt and 12pt
fontsize: 9pt

# Optional: Force one-column layout, default is two-column
# one_column: true

# Optional: Enables lineno mode, but only if one_column mode is also true
# lineno: true

# Optional: Enable one-sided layout, default is two-sided
#one_sided: true

# Optional: Enable section numbering, default is unnumbered
#numbersections: true

# Optional: Specify the depth of section number, default is 5
#secnumdepth: 5

# Optional: Skip inserting final break between acknowledgements, default is false
skip_final_break: true

# Optional: Bibliography 
bibliography: pinp.bib

# Optional: Enable a 'Draft' watermark on the document
#watermark: true

# Customize footer, eg by referencing the vignette
footer_contents: "YourPackage Vignette"

# Produce a pinp document
output: pinp::pinp

# Required: Vignette metadata for inclusion in a package.
vignette: >
  %\VignetteIndexEntry{YourPackage-vignetteentry}
  %\VignetteKeywords{YourPackage, r, anotherkeyword}
  %\VignettePackage{YourPackage}
  %\VignetteEngine{knitr::rmarkdown}
---

## Data Preparation 

There are two telematics data set from independent sensors: GPS in smartphone, OBDII. The two data sets are provided as two separate file. Here we assume that the two `json` files are extracted in the working directory, which means you have the following two files in the working directory:

> mobile_trips.json, obd2_trips.json

## Data load and structure

Since the two files are recorded as `json` format, `jsonlite` package will be used to load the data.

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(jsonlite)
library(ggplot2)
# read obd2 trip & mobile trip
obd2_data <- fromJSON("../obd2_trips.json")
mobile_data <- fromJSON("../mobile_trips.json")
```

```{r eval=FALSE}
library(jsonlite)

# read mobile trip & obd2 trip
mobile_data <- fromJSON("./mobile_trips.json")
obd2_data <- fromJSON("./obd2_trips.json")
```

Smartphone data set consisists of 44 trips and OBDII data set consists of 41 trips. The colum names of the each data set and the data types are as follows:

- OBDII data
  - trip_id (`char`), timestamp (`dbl`), speed (`int`)
- Mobile data
  - trip_id (`char`), created_at (`dbl`), timestamp (`dbl`), speed (`dbl`), accuracy (`int`)

## Visualization of sample trips

Fig \ref{fig:rawplot_obd2} shows the speed graph of a sample trip from OBDII data. As we can see, the OBDII trip was recorded for about 1,200 seconds and we do not know the unit for the recorded speed. Fig \ref{fig:rawplot_mobile} shows the speed graph of a sample trip from mobile data. Note that the scale of x-axis has been adjusted as zero. By examing the data set littel bit, it can be easily realized that the first trip from each sources corresponds to each other as in Fig. \ref{fig:rawplot_obd2} and Fig \ref{fig:rawplot_mobile}. As we can see the whole trip data from smartphone corresponds to the trip data from OBDII around 300 seconds.

```{r rawplot_obd2, fig.width=3, fig.height=3, cache=TRUE, echo=FALSE, fig.cap="A sample of speed graph of OBDII (the 1st trip)."}
library(ggplot2)
obd2_trip_sample1 <- obd2_data[[1]]
ggplot(obd2_trip_sample1, aes(timestamp, speed)) +
    geom_line() +
    labs(x = "Time (sec.)",
       y = "Speed (unknown)") +
    theme(legend.position="none") +
    theme_bw()
```

```{r rawplot_mobile, fig.width=3, fig.height=3, cache=TRUE, echo=FALSE, fig.cap="A sample of speed graph of Smartphone (the 1st trip)."}
mobile_trip_sample1 <- mobile_data[[1]]
ggplot(mobile_trip_sample1, aes(timestamp  - timestamp[1], speed)) +
    geom_line() +
    labs(x = "Time (sec.)",
       y = "Speed (unknown)") +
    theme(legend.position="none")+
    theme_bw()
```

### Determine the conversion factor between speed scale

Using this knowledge we found, we can figure out there is a conversion factor between the two different speed scale from each sources. If thoese sensor recorded the same trip, thier maximum speed should be the same. Thus, we can calculate the conversion factor as follows:

```{r}
# Conversion factor
max(obd2_trip_sample1$speed) / 
  max(mobile_trip_sample1$speed)
```

We can see that it is around 3.6. There are many units for speed such as miles per hour (mph), kilometers per hour (km/h), etc. Using the cue that the smartphone sensor should use either `mph` or `km/h`, we can easily guess that the OBDII uses `m/s` since the relationship between `km/h` and `m/s` is as follows:

$$
1 \ m/s = 3.6 \ km/h
$$

Thus, using conversion factor and the lagging time (300 sec.), we can guess our final output should be similar to Fig \ref{fig:speedplot}. From now on, we will use `km/h` as a speed scale since the result plot re-confirms that the unit of each sensors.

```{r speedplot, fig.width=3, fig.height=3, cache=TRUE, echo=FALSE, fig.cap="A sample output of matched speed graph."}
ggplot(obd2_trip_sample1, aes(timestamp, speed/3.6)) +
    geom_line() +
    geom_line(data = mobile_trip_sample1, aes(x = timestamp - timestamp[1]  + 270, y = speed, col = "red")) +
    labs(x = "Time (sec.)",
       y = "Speed (km/h)") +
    theme(legend.position="none") +
    theme_bw()
# with(obd2_trip_sample1, plot(timestamp, speed/3.6, type = "l"))
# with(mobile_trip_sample1, 
#      points(timestamp - timestamp[1]  + 270,
#                            speed, col = "red",
#                            type = "l"))
```

## Lagging time detection algorithm

The next step is to automatically determine the lag time given that we have two matched trips. We will use the same sample trips used in the previous section. In Fig. \ref{fig:speedplot}, the exact lag time for smartphone trip data was 270 seconds. To detect the lagging time, we need to consider every possible combination of these two trip by using sliding window algorithm. A nice visualization of this concept can be found at [here](https://en.wikipedia.org/wiki/Convolution#/media/File:Convolution_of_spiky_function_with_box2.gif). We consider the speed graph from OBDII as a fixed function and the speed graph from smartphone as a floating function in the algorithm.

Let $x \in \mathbb{R^+}$ be a real positive vector of size $n_x$ whose elements represent the speeds or a trip from smartphone, while $y \in \mathbb{R^+}$ and $n_y$ represents the speed and the size of the speed vector from OBDII repectively.

\begin{equation*}
  \begin{aligned}
    x & = (x_1, x_2, ..., x_{n_x})^T \\
    y & = (y_1, y_2, ..., y_{n_y})^T
  \label{eqn:speedvector} 
  \end{aligned}
\end{equation*}

To implement the sliding window algorithm, we uses a dummy variable `k` from 1 to $n_x + n_y$ to search all the possible overlapped combination of the two graph. For example, when $k = 1$, we consider the situation where $x_{n_x}$ and $y_1$ are overlapped each other. When $k=2$, $(x_{n_x - 1}, x_{n_x})$ and $(y_1, y_2)$ are considered. Thus, for any $k \leq n_x+n_y$ where $k \in \mathbb{N}$, the overlapped vectors, $x^*$ and $y^*$ can be written as follows;

\begin{equation}
  \begin{aligned}
  x^* &= (max(n_x - k, 1), ..., n_x - max(0, k - n_y))^T \\
  y^* &= (max(k-n_x, 1), ..., min(n_y, k))^T
  \label{eqn:slidingwindow} 
  \end{aligned}
\end{equation}

Equation \ref{eqn:slidingwindow} shows the compact expression for the three cases:

- Case 1: $k < n_x$ and $k < n_y$
  - $x^* = (n_x - k, ..., n_x)$
  - $y^* = (1, ..., k)$
- Case 2: $k > n_x$ and $k < n_y$
  - $x^* = (1, ..., n_x)$
  - $y^* = (k-n_x, ..., k)$
- Case 3: $k > n_x$ and $k > n_y$
  - $x^* = (1, ..., n_y - (k-n_x))$
  - $y^* = ((k-n_x), ..., n_y)$

## Measure for the similarity

There are many measures for the similarity of the two functions whose domains are the same: area under the difference of the two functions, maximum difference of the two functions values, etc. Among these, the following measure is used for detecting the similarity between the two speed vectors:

\begin{equation}
  \begin{aligned}
 f(x, y) = \frac{\sqrt{\left(\sum_{i\in A}\left(x_{i}-y_{i}\right)^{2}\right)}}{|A|} + \frac{\lambda}{|A|}
  \label{eqn:sumofsquare} 
  \end{aligned}
\end{equation}
where the vector $x$ and $y$ are the speed vector from smartphone and OBDII, and the set $A$ is the collection of the pair of coordinates of OBDII and smartphone speed vectors overlapped each other for fixed $k$. Note that the function $|.|$ indicates the caldinality of a set. The reason of the division in Equation \ref{eqn:sumofsquare} is to calculate the average of the errors. 

Also, the second term can be thought as a penalty function that prevents the case where the length of the overlapped is too short, so the dissimilarity is too small. We can put the weights on the panalty using $\lambda$, and we uses 10 for $\lambda$ value for this case. Since the value of $f(x, y)$ decreases when the two vector $x$ and $y$ are similar to each other, the interpretation of the measure should be dissimilarity of the two vector. Fig. \ref{fig:laggedtime} shows the dissimilarity with respect to the $k$ from 1 to 2354, which is the summation of the length of speed vector from OBDII and smartphone. The index which makes the dissimilarity to be the smallest value is $k = 1374$. According to Equation \ref{eqn:slidingwindow}, this corresponds to the 255th time stamp of the OBDII trip. 

```{r laggedtime, fig.width=3, fig.height=3, echo=FALSE, warning=FALSE, fig.cap="Dissimilarity measure for w.r.t. $k$"}
source("report_issaclee.R")
dis_result <- SimilarityMeasure(obd2_trip_sample1,
                                mobile_trip_sample1)
ggplot(data.frame(index = 1:length(dis_result),
                  dissimilarity = dis_result),
       aes(index, dissimilarity)) +
    geom_line() + ylim(0, 2) +
    theme(legend.position="none") +
    theme_bw()
```

## Find the best matched trips

In the previous section, we have discussed how to find the lagging time using dissimilarity measure. To find a best matched trip among the collection of the OBDII trips for a given smartphone trip, we can find the OBDII trip whose minimum of the dissmilarity with the given smartphone trip is the lowest among the whole collection of the OBDII data set. However, since we cannnot guarantee that the lowest minimum of the dissmilarity implies that the two trip from each sources actually matched each other, we set $0.1$ as a threshold. Thus, if the lowest minimum dissimilarity is less than 0.1, we decide that the pair of OBDII trip and smartphone trip are matched each other. Fig. \ref{fig:dissimilarity} represents the minimum of dissimilarity for each trips in OBDII data with the first trip in mobile data set. The dotted line, in Fig. \ref{fig:dissimilarity}, indicates the threshold for matched trip. Since the minimum of the dissimilarity of the first trip is less than the 0.1, we choose the first trip in OBDII data as the best matched trip with the first trip in mobile data.

```{r dissimilarity, fig.width=3, fig.height=3, echo=FALSE, warning=FALSE, fig.cap="Minimum values of dissimilarity for each trips in OBDII data set"}
match_result <- lapply(obd2_data, SimilarityMeasure_min,
                       mobile_trip_data = mobile_trip_sample1)
ggplot(data.frame(dissimilarity = unlist(match_result),
                  index = 1:length(unlist(match_result)))) +
  geom_line(aes(x = index, y = dissimilarity)) +
  geom_hline(yintercept = 0.1, linetype = 2) +
  theme_bw()
```

## User instruction

### Load data

You can load the JSON file into `R` using `jsonlite` package as at the biginning of this document.

```{r eval=FALSE}
library(jsonlite)

# read mobile trip & obd2 trip
mobile_data <- fromJSON("./mobile_trips.json")
obd2_data <- fromJSON("./obd2_trips.json")
```

### Find the best OBDII trip for given smartphone trip

The following code will find the best OBDII trip which matches with `given_trip` mobile trip, and save the information into `match_info`.

```{r}
# Select the second trip in the mobile data set
given_trip <- mobile_data[[2]]

# Find the best trip from OBDII data set
match_info <- FindBestTrip(given_trip, obd2_data)
```

The `match_info` variable has the matched result information. We can see that there are seven information as follows:

```{r}
summary(match_info)
```

```{r}
# Visualization
VisTrip(given_trip, obd2_data, match_info)
```

